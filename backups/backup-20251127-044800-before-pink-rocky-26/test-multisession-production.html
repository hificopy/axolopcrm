<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Session Production Test - Axolop CRM</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        min-height: 100vh;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        padding: 30px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }
      .header {
        text-align: center;
        margin-bottom: 30px;
      }
      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        color: transparent;
        padding: 2px 6px;
      }
      .header p {
        font-size: 1.1rem;
        opacity: 0.9;
      }
      .test-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }
      .test-card {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 20px;
        transition: all 0.3s ease;
      }
      .test-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
      }
      .test-card h3 {
        margin: 0 0 15px 0;
        color: #4ade80;
        font-size: 1.2rem;
      }
      .test-status {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
      }
      .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
      }
      .status-pending {
        background: #fbbf24;
      }
      .status-running {
        background: #34d399;
      }
      .status-passed {
        background: #10b981;
      }
      .status-failed {
        background: #ef4444;
      }
      .test-button {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
        margin: 5px;
      }
      .test-button:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }
      .test-button:disabled {
        background: #6b7280;
        cursor: not-allowed;
        transform: none;
      }
      .results {
        background: rgba(0, 0, 0, 0.8);
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
      }
      .summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }
      .summary-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 6px;
        text-align: center;
      }
      .summary-value {
        font-size: 2rem;
        font-weight: bold;
        color: #4ade80;
      }
      .summary-label {
        font-size: 0.9rem;
        opacity: 0.8;
        margin-top: 5px;
      }
      .log {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 15px;
        font-family: "Courier New", monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
        white-space: pre-wrap;
        margin-top: 20px;
      }
      .instructions {
        background: rgba(74, 222, 128, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
      }
      .instructions h4 {
        color: #fbbf24;
        margin: 0 0 10px 0;
      }
      .instructions ol {
        margin: 0;
        padding-left: 20px;
      }
      .instructions li {
        margin-bottom: 8px;
        line-height: 1.5;
      }
      .success {
        color: #4ade80;
      }
      .warning {
        color: #fbbf24;
      }
      .error {
        color: #ef4444;
      }
      .highlight {
        background: rgba(74, 222, 128, 0.2);
        padding: 2px 4px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üß™ MULTI-SESSION PRODUCTION TEST</h1>
        <p>Comprehensive testing for Axolop CRM multi-session coordination</p>
      </div>

      <div class="instructions">
        <h4>üìã Test Instructions</h4>
        <ol>
          <li>
            Open this page in <strong>5+ browser tabs</strong> simultaneously
          </li>
          <li>
            Click "Run All Tests" in one tab to start comprehensive testing
          </li>
          <li>Watch for real-time coordination between tabs</li>
          <li>Check results summary for production readiness</li>
          <li>Verify no race conditions, deadlocks, or conflicts</li>
          <li>
            Ensure all tabs can work simultaneously without data corruption
          </li>
        </ol>
      </div>

      <div class="test-grid">
        <div class="test-card">
          <h3>üèÜ Master Election</h3>
          <div class="test-status">
            <span>Status:</span>
            <span
              id="master-status"
              class="status-indicator status-pending"
            ></span>
            <span id="master-text">Pending</span>
          </div>
          <button class="test-button" onclick="testMasterElection()">
            Test Master Election
          </button>
          <button class="test-button" onclick="testMasterElectionStress()">
            Stress Test (5 tabs)
          </button>
        </div>

        <div class="test-card">
          <h3>üîí Mutex Mechanism</h3>
          <div class="test-status">
            <span>Status:</span>
            <span
              id="mutex-status"
              class="status-indicator status-pending"
            ></span>
            <span id="mutex-text">Pending</span>
          </div>
          <button class="test-button" onclick="testMutexBasic()">
            Test Basic Mutex
          </button>
          <button class="test-button" onclick="testMutexDeadlock()">
            Test Deadlock Prevention
          </button>
          <button class="test-button" onclick="testMutexConcurrency()">
            Test Concurrency
          </button>
        </div>

        <div class="test-card">
          <h3>ü™ü Modal Coordination</h3>
          <div class="test-status">
            <span>Status:</span>
            <span
              id="modal-status"
              class="status-indicator status-pending"
            ></span>
            <span id="modal-text">Pending</span>
          </div>
          <button class="test-button" onclick="testModalPermissions()">
            Test Modal Permissions
          </button>
          <button class="test-button" onclick="testModalSync()">
            Test Modal Sync
          </button>
        </div>

        <div class="test-card">
          <h3>üì° Cross-Tab Communication</h3>
          <div class="test-status">
            <span>Status:</span>
            <span
              id="comm-status"
              class="status-indicator status-pending"
            ></span>
            <span id="comm-text">Pending</span>
          </div>
          <button class="test-button" onclick="testCommunication()">
            Test Communication
          </button>
          <button class="test-button" onclick="testBroadcastStress()">
            Stress Test Broadcast
          </button>
        </div>

        <div class="test-card">
          <h3>üîê Session Validation</h3>
          <div class="test-status">
            <span>Status:</span>
            <span
              id="session-status"
              class="status-indicator status-pending"
            ></span>
            <span id="session-text">Pending</span>
          </div>
          <button class="test-button" onclick="testSessionValidation()">
            Test Session Validation
          </button>
          <button class="test-button" onclick="testSessionConflicts()">
            Test Conflict Detection
          </button>
        </div>

        <div class="test-card">
          <h3>üíæ Storage Management</h3>
          <div class="test-status">
            <span>Status:</span>
            <span
              id="storage-status"
              class="status-indicator status-pending"
            ></span>
            <span id="storage-text">Pending</span>
          </div>
          <button class="test-button" onclick="testStorageQuota()">
            Test Storage Quota
          </button>
          <button class="test-button" onclick="testCleanup()">
            Test Cleanup Mechanism
          </button>
        </div>
      </div>

      <div class="results">
        <h3>üìä Test Results Summary</h3>
        <div class="summary">
          <div class="summary-item">
            <div class="summary-value" id="total-tests">0</div>
            <div class="summary-label">Total Tests</div>
          </div>
          <div class="summary-item">
            <div class="summary-value" id="passed-tests">0</div>
            <div class="summary-label">Passed</div>
          </div>
          <div class="summary-item">
            <div class="summary-value" id="failed-tests">0</div>
            <div class="summary-label">Failed</div>
          </div>
          <div class="summary-item">
            <div class="summary-value" id="success-rate">0%</div>
            <div class="summary-label">Success Rate</div>
          </div>
          <div class="summary-item">
            <div class="summary-value" id="test-duration">0ms</div>
            <div class="summary-label">Duration</div>
          </div>
          <div class="summary-item">
            <div class="summary-value" id="production-ready">‚ùå</div>
            <div class="summary-label">Production Ready</div>
          </div>
        </div>
        <div id="detailed-results" class="log"></div>
      </div>
    </div>

    <script type="module">
      // Import TabCoordinator for testing
      class TabCoordinatorTest {
        constructor() {
          this.tabId = this.generateTabId();
          this.isMaster = false;
          this.heartbeatInterval = null;
          this.eventListeners = new Map();
          this.mutexLocks = new Map();
          this.lastHeartbeat = Date.now();
          this.testResults = [];
          this.testStartTime = Date.now();

          this.initialize();
        }

        generateTabId() {
          return `test_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
        }

        async initialize() {
          console.log(`[TestSuite] Initializing test tab ${this.tabId}`);
          this.initializeBroadcastChannel();
          await this.electMaster();
          this.startHeartbeat();

          window.addEventListener("beforeunload", () => {
            this.cleanup();
          });
        }

        initializeBroadcastChannel() {
          try {
            this.broadcastChannel = new BroadcastChannel(
              "axolop-tab-coordination-test",
            );
            this.broadcastChannel.addEventListener(
              "message",
              this.handleBroadcastMessage.bind(this),
            );
          } catch (error) {
            console.warn(
              "[TestSuite] BroadcastChannel not supported, using localStorage fallback",
            );
            window.addEventListener(
              "storage",
              this.handleStorageEvent.bind(this),
            );
          }
        }

        handleBroadcastMessage(event) {
          const { type, data, tabId, timestamp } = event.data;
          if (tabId === this.tabId) return;

          console.log(`[TestSuite] Received broadcast: ${type} from ${tabId}`);

          switch (type) {
            case "HEARTBEAT":
              this.handleExternalHeartbeat(tabId, timestamp);
              break;
            case "MASTER_ELECTION":
              this.handleMasterElection(data, tabId);
              break;
            case "MUTEX_LOCK":
              this.handleMutexLock(data, tabId);
              break;
            case "MUTEX_UNLOCK":
              this.handleMutexUnlock(data, tabId);
              break;
            case "TEST_MESSAGE":
              this.handleTestMessage(data, tabId);
              break;
          }
        }

        handleStorageEvent(event) {
          if (event.key === "axolop-tab-broadcast-test") {
            try {
              const message = JSON.parse(event.newValue);
              this.handleBroadcastMessage({ data: message });
            } catch (error) {
              console.warn("[TestSuite] Failed to parse storage event:", error);
            }
          }
        }

        broadcast(type, data = {}) {
          const message = {
            type,
            data,
            tabId: this.tabId,
            timestamp: Date.now(),
          };

          try {
            if (this.broadcastChannel) {
              this.broadcastChannel.postMessage(message);
            } else {
              localStorage.setItem(
                "axolop-tab-broadcast-test",
                JSON.stringify(message),
              );
              setTimeout(() => {
                try {
                  localStorage.removeItem("axolop-tab-broadcast-test");
                } catch (error) {
                  // Ignore cleanup errors
                }
              }, 100);
            }
          } catch (error) {
            console.warn("[TestSuite] Failed to broadcast message:", error);
          }
        }

        async electMaster() {
          const currentMaster = this.getStoredMaster();

          if (!currentMaster || this.isTabExpired(currentMaster)) {
            const electionId =
              Date.now() + "_" + Math.random().toString(36).substring(2);
            const candidateInfo = {
              tabId: this.tabId,
              electionId,
              timestamp: Date.now(),
              lastHeartbeat: Date.now(),
            };

            try {
              localStorage.setItem(
                "axolop_master_election_test",
                JSON.stringify(candidateInfo),
              );
              await new Promise((resolve) => setTimeout(resolve, 50));

              const stored = localStorage.getItem(
                "axolop_master_election_test",
              );
              const winner = JSON.parse(stored);

              if (winner.electionId === electionId) {
                this.setAsMaster();
              } else {
                this.isMaster = false;
              }

              localStorage.removeItem("axolop_master_election_test");
            } catch (error) {
              console.error("[TestSuite] Election failed:", error);
              this.isMaster = false;
            }
          } else {
            await this.challengeMaster(currentMaster);
          }
        }

        getStoredMaster() {
          try {
            const master = localStorage.getItem("axolop_master_tab_test");
            return master ? JSON.parse(master) : null;
          } catch (error) {
            return null;
          }
        }

        isTabExpired(tabInfo) {
          return Date.now() - tabInfo.lastHeartbeat > 10000;
        }

        setAsMaster() {
          this.isMaster = true;
          const masterInfo = {
            tabId: this.tabId,
            timestamp: Date.now(),
            lastHeartbeat: Date.now(),
          };

          localStorage.setItem(
            "axolop_master_tab_test",
            JSON.stringify(masterInfo),
          );
          this.broadcast("MASTER_ELECTION", {
            action: "become_master",
            masterInfo,
          });
          console.log(`[TestSuite] Tab ${this.tabId} became master`);
        }

        async challengeMaster(currentMaster) {
          if (this.tabId < currentMaster.tabId) {
            this.setAsMaster();
          } else {
            this.isMaster = false;
          }
        }

        handleMasterElection(data, tabId) {
          if (data.action === "become_master") {
            if (this.isMaster && this.tabId !== tabId) {
              this.relinquishMaster();
            }
            this.isMaster = false;
          }
        }

        relinquishMaster() {
          if (this.isMaster) {
            this.isMaster = false;
            localStorage.removeItem("axolop_master_tab_test");
            this.broadcast("MASTER_RELINQUISH");
            console.log(
              `[TestSuite] Tab ${this.tabId} relinquished master status`,
            );
          }
        }

        startHeartbeat() {
          this.heartbeatInterval = setInterval(() => {
            this.lastHeartbeat = Date.now();

            if (this.isMaster) {
              const masterInfo = this.getStoredMaster();
              if (masterInfo && masterInfo.tabId === this.tabId) {
                masterInfo.lastHeartbeat = Date.now();
                localStorage.setItem(
                  "axolop_master_tab_test",
                  JSON.stringify(masterInfo),
                );
              }
            }

            this.broadcast("HEARTBEAT", { isMaster: this.isMaster });
          }, 3000);
        }

        handleExternalHeartbeat(tabId, timestamp) {
          console.log(`[TestSuite] Heartbeat from tab: ${tabId}`);
        }

        async acquireMutex(lockName, timeout = 5000, maxRetries = 3) {
          if (this.mutexLocks.has(lockName)) {
            return false;
          }

          let attempt = 0;
          while (attempt < maxRetries) {
            attempt++;

            const lockKey = `axolop_mutex_test_${lockName}`;
            const lockData = {
              tabId: this.tabId,
              timestamp: Date.now(),
              expires: Date.now() + timeout,
              attempt,
            };

            try {
              localStorage.setItem(lockKey, JSON.stringify(lockData));

              const stored = localStorage.getItem(lockKey);
              const parsed = JSON.parse(stored);

              if (parsed.tabId === this.tabId && parsed.attempt === attempt) {
                if (Date.now() < parsed.expires) {
                  this.mutexLocks.set(lockName, parsed.expires);
                  this.broadcast("MUTEX_LOCK", { lockName, tabId: this.tabId });
                  return true;
                } else {
                  return false; // Expired lock
                }
              }
            } catch (error) {
              console.warn(
                `[TestSuite] Mutex attempt ${attempt} failed:`,
                error,
              );
            }

            if (attempt < maxRetries) {
              await new Promise((resolve) =>
                setTimeout(resolve, 100 * attempt),
              );
            }
          }

          return false;
        }

        releaseMutex(lockName) {
          if (!this.mutexLocks.has(lockName)) {
            return false;
          }

          const lockKey = `axolop_mutex_test_${lockName}`;

          try {
            localStorage.removeItem(lockKey);
            this.mutexLocks.delete(lockName);
            this.broadcast("MUTEX_UNLOCK", { lockName, tabId: this.tabId });
            return true;
          } catch (error) {
            console.warn("[TestSuite] Failed to release mutex:", error);
            return false;
          }
        }

        handleMutexLock(data, tabId) {
          if (tabId !== this.tabId) {
            console.log(
              `[TestSuite] Mutex acquired by another tab: ${data.lockName} by ${tabId}`,
            );
          }
        }

        handleMutexUnlock(data, tabId) {
          if (tabId !== this.tabId) {
            console.log(
              `[TestSuite] Mutex released by another tab: ${data.lockName} by ${tabId}`,
            );
          }
        }

        canShowModal(modalType) {
          return modalType === "mandatory" ? this.isMaster : true;
        }

        handleTestMessage(data, tabId) {
          console.log(
            `[TestSuite] Test message from ${tabId}: ${JSON.stringify(data)}`,
          );
          this.testResults.push({
            testName: "Cross-Tab Communication",
            passed: true,
            message: `Received message from ${tabId}`,
            timestamp: Date.now(),
          });
        }

        cleanup() {
          if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
          }

          this.mutexLocks.forEach((_, lockName) => {
            this.releaseMutex(lockName);
          });

          if (this.isMaster) {
            localStorage.removeItem("axolop_master_tab_test");
          }

          if (this.broadcastChannel) {
            this.broadcastChannel.close();
          }

          window.removeEventListener("storage", this.handleStorageEvent);
        }

        addTestResult(testName, passed, message, details = null) {
          const result = {
            testName,
            passed,
            message,
            details,
            timestamp: Date.now(),
          };

          this.testResults.push(result);
          this.updateResults();
        }

        updateResults() {
          const totalTests = this.testResults.length;
          const passedTests = this.testResults.filter((r) => r.passed).length;
          const failedTests = totalTests - passedTests;
          const successRate =
            totalTests > 0 ? ((passedTests / totalTests) * 100).toFixed(1) : 0;
          const testDuration = Date.now() - this.testStartTime;
          const allPassed = failedTests === 0;

          // Update UI
          document.getElementById("total-tests").textContent = totalTests;
          document.getElementById("passed-tests").textContent = passedTests;
          document.getElementById("failed-tests").textContent = failedTests;
          document.getElementById("success-rate").textContent =
            `${successRate}%`;
          document.getElementById("test-duration").textContent =
            `${testDuration}ms`;
          document.getElementById("production-ready").textContent = allPassed
            ? "‚úÖ YES"
            : "‚ùå NO";

          // Update detailed log
          const logElement = document.getElementById("detailed-results");
          logElement.innerHTML = this.testResults
            .map((r) => {
              const status = r.passed ? "‚úÖ PASS" : "‚ùå FAIL";
              return `${status} ${r.testName}: ${r.message}`;
            })
            .join("\\n");

          console.log("üìä Test Results Updated:", {
            totalTests,
            passedTests,
            failedTests,
            successRate,
            allPassed,
          });
        }

        // Test Methods
        async testMasterElection() {
          this.updateTestStatus("master", "running");

          try {
            // Clear any existing master
            localStorage.removeItem("axolop_master_tab_test");
            localStorage.removeItem("axolop_master_election_test");

            // Open multiple tabs to test election
            const testWindows = [];
            for (let i = 0; i < 3; i++) {
              const testWindow = window.open(
                "",
                "_blank",
                "width=400,height=300",
              );
              testWindows.push(testWindow);
            }

            // Wait for all tabs to initialize
            await new Promise((resolve) => setTimeout(resolve, 2000));

            // Check election results
            const masterCount = testWindows.filter((w) => {
              try {
                return w.testTabCoordinator?.isMaster;
              } catch (e) {
                return false;
              }
            }).length;

            // Close test windows
            testWindows.forEach((w) => w.close());

            const success = masterCount === 1;
            this.addTestResult(
              "Master Election",
              success,
              success
                ? "Exactly one master elected"
                : `${masterCount} masters elected (race condition)`,
              { masterCount, testWindows: testWindows.length },
            );

            this.updateTestStatus("master", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult(
              "Master Election",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("master", "failed");
          }
        }

        async testMutexBasic() {
          this.updateTestStatus("mutex", "running");

          try {
            const lock1 = await this.acquireMutex("test-basic", 2000);
            const lock2 = await this.acquireMutex("test-basic", 500); // Should fail

            const success = lock1 && !lock2;
            this.addTestResult(
              "Mutex Basic",
              success,
              success ? "Mutex working correctly" : "Mutex has issues",
              { lock1, lock2 },
            );

            this.updateTestStatus("mutex", success ? "passed" : "failed");

            // Cleanup
            if (lock1) this.releaseMutex("test-basic");
          } catch (error) {
            this.addTestResult("Mutex Basic", false, `Error: ${error.message}`);
            this.updateTestStatus("mutex", "failed");
          }
        }

        async testMutexDeadlock() {
          this.updateTestStatus("mutex", "running");

          try {
            // Simulate potential deadlock
            const lock1 = await this.acquireMutex("test-deadlock", 10000);

            // Simulate tab crash by not releasing
            setTimeout(async () => {
              const lock2 = await this.acquireMutex("test-deadlock", 2000);

              const success = lock1 && !lock2;
              this.addTestResult(
                "Mutex Deadlock Prevention",
                success,
                success
                  ? "Deadlock prevention working"
                  : "Deadlock prevention failed",
                { lock1Held: !!lock1, lock2Attempted: !!lock2 },
              );

              // Cleanup
              if (lock1) this.releaseMutex("test-deadlock");

              this.updateTestStatus("mutex", success ? "passed" : "failed");
            }, 1000);
          } catch (error) {
            this.addTestResult(
              "Mutex Deadlock Prevention",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("mutex", "failed");
          }
        }

        async testMutexConcurrency() {
          this.updateTestStatus("mutex", "running");

          try {
            const promises = [];
            for (let i = 0; i < 5; i++) {
              promises.push(this.acquireMutex(`test-concurrent-${i}`, 2000));
            }

            const results = await Promise.all(promises);
            const acquiredCount = results.filter((r) => r).length;

            // Release all locks
            for (let i = 0; i < 5; i++) {
              this.releaseMutex(`test-concurrent-${i}`);
            }

            const success = acquiredCount === 1; // Only one should succeed
            this.addTestResult(
              "Mutex Concurrency",
              success,
              success
                ? "Concurrency control working"
                : "Concurrency control failed",
              { acquiredCount, totalAttempts: 5 },
            );

            this.updateTestStatus("mutex", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult(
              "Mutex Concurrency",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("mutex", "failed");
          }
        }

        async testModalPermissions() {
          this.updateTestStatus("modal", "running");

          try {
            const canShowMandatory = this.canShowModal("mandatory");
            const canShowOptional = this.canShowModal("optional");

            const success = this.isMaster
              ? canShowMandatory && !canShowOptional
              : !canShowMandatory && canShowOptional;

            this.addTestResult(
              "Modal Permissions",
              success,
              success
                ? "Modal permissions working correctly"
                : "Modal permissions incorrect",
              { isMaster: this.isMaster, canShowMandatory, canShowOptional },
            );

            this.updateTestStatus("modal", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult(
              "Modal Permissions",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("modal", "failed");
          }
        }

        async testModalSync() {
          this.updateTestStatus("modal", "running");

          try {
            // Test modal state synchronization
            const initialState = this.canShowModal("mandatory");

            // Broadcast modal state change
            this.broadcastModalState("mandatory", true);

            // Wait for sync
            await new Promise((resolve) => setTimeout(resolve, 1000));

            // Check if state is consistent
            const finalState = this.canShowModal("mandatory");

            const success = initialState === finalState;
            this.addTestResult(
              "Modal Sync",
              success,
              success
                ? "Modal state synchronization working"
                : "Modal state synchronization failed",
              { initialState, finalState },
            );

            this.updateTestStatus("modal", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult("Modal Sync", false, `Error: ${error.message}`);
            this.updateTestStatus("modal", "failed");
          }
        }

        async testCommunication() {
          this.updateTestStatus("comm", "running");

          try {
            const testMessage = {
              timestamp: Date.now(),
              test: "communication",
            };

            // Send test message
            this.broadcast("TEST_MESSAGE", testMessage);

            // Wait for message processing
            await new Promise((resolve) => setTimeout(resolve, 1000));

            const success = this.testResults.some(
              (r) => r.testName === "Cross-Tab Communication" && r.passed,
            );

            this.addTestResult(
              "Cross-Tab Communication",
              success,
              success
                ? "Communication working correctly"
                : "Communication failed",
              { messageSent: testMessage },
            );

            this.updateTestStatus("comm", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult(
              "Cross-Tab Communication",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("comm", "failed");
          }
        }

        async testBroadcastStress() {
          this.updateTestStatus("comm", "running");

          try {
            const messageCount = 10;
            const promises = [];

            // Send multiple messages rapidly
            for (let i = 0; i < messageCount; i++) {
              promises.push(
                this.broadcast("TEST_MESSAGE", {
                  index: i,
                  timestamp: Date.now(),
                }),
              );
            }

            await Promise.all(promises);

            // Check if all messages were processed
            const receivedCount = this.testResults.filter(
              (r) => r.testName === "Cross-Tab Communication" && r.passed,
            ).length;

            const success = receivedCount >= messageCount * 0.8; // Allow for some message loss
            this.addTestResult(
              "Broadcast Stress",
              success,
              success
                ? "Broadcast stress test passed"
                : "Broadcast stress test failed",
              {
                messageCount,
                receivedCount,
                successRate: `${((receivedCount / messageCount) * 100).toFixed(1)}%`,
              },
            );

            this.updateTestStatus("comm", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult(
              "Broadcast Stress",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("comm", "failed");
          }
        }

        async testSessionValidation() {
          this.updateTestStatus("session", "running");

          try {
            // Test session consistency across tabs
            const initialValidation = this.testResults.filter(
              (r) => r.testName === "Session Validation" && r.passed,
            ).length;

            // Simulate session conflict
            this.broadcast("SESSION_CONFLICT", { type: "test_conflict" });

            await new Promise((resolve) => setTimeout(resolve, 1000));

            const conflictDetected = this.testResults.some(
              (r) => r.testName === "Session Conflict Detection" && r.passed,
            );

            const success = conflictDetected;
            this.addTestResult(
              "Session Validation",
              success,
              success
                ? "Session validation working correctly"
                : "Session validation failed",
              { initialValidation, conflictDetected },
            );

            this.updateTestStatus("session", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult(
              "Session Validation",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("session", "failed");
          }
        }

        async testSessionConflicts() {
          this.updateTestStatus("session", "running");

          try {
            // Test multiple types of session conflicts
            const conflicts = [
              "user_mismatch",
              "invalidated",
              "tab_session_mismatch",
            ];
            let detectedConflicts = [];

            for (const conflictType of conflicts) {
              this.broadcast("SESSION_CONFLICT", { type: conflictType });
              await new Promise((resolve) => setTimeout(resolve, 500));

              const detected = this.testResults.some(
                (r) =>
                  r.testName === "Session Conflict Detection" &&
                  r.passed &&
                  r.details?.type === conflictType,
              );

              if (detected) {
                detectedConflicts.push(conflictType);
              }
            }

            const success = detectedConflicts.length === conflicts.length;
            this.addTestResult(
              "Session Conflict Detection",
              success,
              success
                ? "All conflict types detected"
                : "Some conflict types missed",
              { detectedConflicts, expectedConflicts: conflicts },
            );

            this.updateTestStatus("session", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult(
              "Session Conflict Detection",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("session", "failed");
          }
        }

        async testStorageQuota() {
          this.updateTestStatus("storage", "running");

          try {
            // Test storage quota handling
            const testData = "x".repeat(1024 * 10); // 10KB test

            localStorage.setItem("axolop_quota_test", testData);

            const canStoreMore = localStorage.setItem(
              "axolop_quota_test",
              "x".repeat(1024 * 11),
            ); // 11KB test

            // Check if data was stored
            const stored = localStorage.getItem("axolop_quota_test");
            const success = stored === testData && !canStoreMore;

            // Cleanup
            localStorage.removeItem("axolop_quota_test");

            this.addTestResult(
              "Storage Quota",
              success,
              success
                ? "Storage quota management working"
                : "Storage quota management failed",
              { testDataSize: testData.length, canStoreMore },
            );

            this.updateTestStatus("storage", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult(
              "Storage Quota",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("storage", "failed");
          }
        }

        async testCleanup() {
          this.updateTestStatus("storage", "running");

          try {
            // Test cleanup mechanism
            const testKeys = [
              "cleanup_test_1",
              "cleanup_test_2",
              "cleanup_test_3",
            ];

            // Set test data with expiration
            const now = Date.now();
            testKeys.forEach((key, index) => {
              localStorage.setItem(
                key,
                JSON.stringify({
                  data: `test_data_${index}`,
                  expires: now + (index + 1) * 2000, // Expire in 2s, 4s, 6s
                }),
              );
            });

            // Trigger cleanup
            await new Promise((resolve) => setTimeout(resolve, 3000));

            // Check cleanup
            const remainingKeys = Array.from(localStorage.keys()).filter(
              (key) => key.startsWith("cleanup_test_"),
            );

            const success = remainingKeys.length === 0;
            this.addTestResult(
              "Cleanup Mechanism",
              success,
              success
                ? "Cleanup mechanism working correctly"
                : "Cleanup mechanism failed",
              {
                initialKeys: testKeys.length,
                remainingKeys: remainingKeys.length,
              },
            );

            this.updateTestStatus("storage", success ? "passed" : "failed");
          } catch (error) {
            this.addTestResult(
              "Cleanup Mechanism",
              false,
              `Error: ${error.message}`,
            );
            this.updateTestStatus("storage", "failed");
          }
        }

        updateTestStatus(testType, status) {
          const statusElement = document.getElementById(`${testType}-status`);
          const textElement = document.getElementById(`${testType}-text`);

          statusElement.className = `status-indicator status-${status}`;

          switch (status) {
            case "pending":
              statusElement.className = "status-indicator status-pending";
              textElement.textContent = "Running...";
              break;
            case "running":
              statusElement.className = "status-indicator status-running";
              textElement.textContent = "Running...";
              break;
            case "passed":
              statusElement.className = "status-indicator status-passed";
              textElement.textContent = "Passed";
              break;
            case "failed":
              statusElement.className = "status-indicator status-failed";
              textElement.textContent = "Failed";
              break;
          }
        }

        async runAllTests() {
          console.log("üß™ Starting comprehensive multi-session test suite...");
          this.testResults = [];
          this.testStartTime = Date.now();

          // Reset all status indicators
          ["master", "mutex", "modal", "comm", "session", "storage"].forEach(
            (type) => {
              this.updateTestStatus(type, "pending");
            },
          );

          // Run tests in sequence
          await this.testMasterElection();
          await new Promise((resolve) => setTimeout(resolve, 1000));

          await this.testMutexBasic();
          await new Promise((resolve) => setTimeout(resolve, 1000));

          await this.testModalPermissions();
          await new Promise((resolve) => setTimeout(resolve, 1000));

          await this.testModalSync();
          await new Promise((resolve) => setTimeout(resolve, 1000));

          await this.testCommunication();
          await new Promise((resolve) => setTimeout(resolve, 1000));

          await this.testSessionValidation();
          await new Promise((resolve) => setTimeout(resolve, 1000));

          await this.testSessionConflicts();
          await new Promise((resolve) => setTimeout(resolve, 1000));

          await this.testStorageQuota();
          await new Promise((resolve) => setTimeout(resolve, 1000));

          await this.testCleanup();
          await new Promise((resolve) => setTimeout(resolve, 1000));

          // Stress tests
          await this.testMutexDeadlock();
          await new Promise((resolve) => setTimeout(resolve, 2000));

          await this.testMutexConcurrency();
          await new Promise((resolve) => setTimeout(resolve, 2000));

          await this.testBroadcastStress();

          console.log("üß™ Comprehensive test suite completed");
          this.updateResults();
        }
      }

      // Initialize test suite
      const testSuite = new TabCoordinatorTest();

      // Global functions for button clicks
      window.testMasterElection = () => testSuite.testMasterElection();
      window.testMasterElectionStress = () => testSuite.testMasterElection();
      window.testMutexBasic = () => testSuite.testMutexBasic();
      window.testMutexDeadlock = () => testSuite.testMutexDeadlock();
      window.testMutexConcurrency = () => testSuite.testMutexConcurrency();
      window.testModalPermissions = () => testSuite.testModalPermissions();
      window.testModalSync = () => testSuite.testModalSync();
      window.testCommunication = () => testSuite.testCommunication();
      window.testBroadcastStress = () => testSuite.testBroadcastStress();
      window.testSessionValidation = () => testSuite.testSessionValidation();
      window.testSessionConflicts = () => testSuite.testSessionConflicts();
      window.testStorageQuota = () => testSuite.testStorageQuota();
      window.testCleanup = () => testSuite.testCleanup();
      window.runAllTests = () => testSuite.runAllTests();

      // Auto-run tests after page load
      setTimeout(() => {
        console.log("üß™ Auto-starting comprehensive test suite...");
        testSuite.runAllTests();
      }, 2000);
    </script>
  </body>
</html>
