<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Session Test - Axolop CRM</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        margin: 0;
        padding: 20px;
        background: #f5f5f5;
      }
      .container {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        margin-bottom: 30px;
      }
      .test-section {
        margin: 20px 0;
        padding: 20px;
        border: 1px solid #e0e0e0;
        border-radius: 6px;
      }
      .btn {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
      }
      .btn:hover {
        background: #0056b3;
      }
      .btn.success {
        background: #28a745;
      }
      .btn.warning {
        background: #ffc107;
      }
      .btn.danger {
        background: #dc3545;
      }
      .result {
        margin: 10px 0;
        padding: 10px;
        border-radius: 4px;
      }
      .result.success {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .result.error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
      .result.info {
        background: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
      }
      .status {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: bold;
        margin: 2px;
      }
      .status.master {
        background: #28a745;
        color: white;
      }
      .status.slave {
        background: #6c757d;
        color: white;
      }
      .log {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        padding: 15px;
        border-radius: 4px;
        font-family: "Courier New", monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üß™ Multi-Session Test Suite</h1>
        <p>Test Axolop CRM's multi-session coordination features</p>
        <p>
          <strong>Instructions:</strong> Open this page in multiple tabs to test
          cross-tab functionality
        </p>
      </div>

      <div class="test-section">
        <h3>üèÜ Tab Status</h3>
        <div id="tabStatus">
          <p>Initializing...</p>
        </div>
        <button class="btn" onclick="checkTabStatus()">Check Status</button>
        <button class="btn" onclick="runAllTests()">Run All Tests</button>
      </div>

      <div class="test-section">
        <h3>üîí Mutex Test</h3>
        <div id="mutexResult">
          <p>Click to test mutex mechanism</p>
        </div>
        <button class="btn" onclick="testMutex()">Test Mutex</button>
        <button class="btn warning" onclick="testMutexConflict()">
          Test Conflict
        </button>
      </div>

      <div class="test-section">
        <h3>ü™ü Modal Coordination Test</h3>
        <div id="modalResult">
          <p>Test modal coordination across tabs</p>
        </div>
        <button class="btn" onclick="testModalPermission()">
          Test Modal Permission
        </button>
        <button class="btn" onclick="simulateModalOpen()">
          Simulate Modal Open
        </button>
      </div>

      <div class="test-section">
        <h3>üì° Communication Test</h3>
        <div id="commResult">
          <p>Test cross-tab communication</p>
        </div>
        <button class="btn" onclick="testCommunication()">
          Send Test Message
        </button>
      </div>

      <div class="test-section">
        <h3>üìä Test Results</h3>
        <div id="testResults">
          <p>No tests run yet</p>
        </div>
        <button class="btn" onclick="clearResults()">Clear Results</button>
        <button class="btn success" onclick="exportResults()">
          Export Results
        </button>
      </div>

      <div class="test-section">
        <h3>üìù Event Log</h3>
        <div id="eventLog" class="log"></div>
        <button class="btn" onclick="clearLog()">Clear Log</button>
      </div>
    </div>

    <script type="module">
      // Import TabCoordinator (simulate it for testing)
      class TabCoordinatorTest {
        constructor() {
          this.tabId = this.generateTabId();
          this.isMaster = false;
          this.heartbeatInterval = null;
          this.eventListeners = new Map();
          this.mutexLocks = new Map();
          this.lastHeartbeat = Date.now();

          this.initialize();
        }

        generateTabId() {
          return `tab_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
        }

        async initialize() {
          this.log(`Initializing tab ${this.tabId}`);
          this.initializeBroadcastChannel();
          await this.electMaster();
          this.startHeartbeat();

          window.addEventListener("beforeunload", () => {
            this.cleanup();
          });
        }

        initializeBroadcastChannel() {
          try {
            this.broadcastChannel = new BroadcastChannel(
              "axolop-tab-coordination",
            );
            this.broadcastChannel.addEventListener(
              "message",
              this.handleBroadcastMessage.bind(this),
            );
          } catch (error) {
            this.log(
              "BroadcastChannel not supported, using localStorage fallback",
            );
            window.addEventListener(
              "storage",
              this.handleStorageEvent.bind(this),
            );
          }
        }

        handleBroadcastMessage(event) {
          const { type, data, tabId, timestamp } = event.data;
          if (tabId === this.tabId) return;

          this.log(`Received broadcast: ${type} from ${tabId}`);

          switch (type) {
            case "HEARTBEAT":
              this.handleExternalHeartbeat(tabId, timestamp);
              break;
            case "MASTER_ELECTION":
              this.handleMasterElection(data, tabId);
              break;
            case "MUTEX_LOCK":
              this.handleMutexLock(data, tabId);
              break;
            case "MUTEX_UNLOCK":
              this.handleMutexUnlock(data, tabId);
              break;
            case "MODAL_STATE":
              this.handleModalState(data, tabId);
              break;
            case "TEST_MESSAGE":
              this.handleTestMessage(data, tabId);
              break;
          }
        }

        handleStorageEvent(event) {
          if (event.key === "axolop-tab-broadcast") {
            try {
              const message = JSON.parse(event.newValue);
              this.handleBroadcastMessage({ data: message });
            } catch (error) {
              this.log("Failed to parse storage event");
            }
          }
        }

        broadcast(type, data = {}) {
          const message = {
            type,
            data,
            tabId: this.tabId,
            timestamp: Date.now(),
          };

          try {
            if (this.broadcastChannel) {
              this.broadcastChannel.postMessage(message);
            } else {
              localStorage.setItem(
                "axolop-tab-broadcast",
                JSON.stringify(message),
              );
              setTimeout(
                () => localStorage.removeItem("axolop-tab-broadcast"),
                100,
              );
            }
          } catch (error) {
            this.log("Failed to broadcast message");
          }
        }

        async electMaster() {
          const currentMaster = this.getStoredMaster();

          if (!currentMaster || this.isTabExpired(currentMaster)) {
            this.setAsMaster();
          } else {
            await this.challengeMaster(currentMaster);
          }
        }

        getStoredMaster() {
          try {
            const master = localStorage.getItem("axolop_master_tab");
            return master ? JSON.parse(master) : null;
          } catch (error) {
            return null;
          }
        }

        isTabExpired(tabInfo) {
          return Date.now() - tabInfo.lastHeartbeat > 10000;
        }

        setAsMaster() {
          this.isMaster = true;
          const masterInfo = {
            tabId: this.tabId,
            timestamp: Date.now(),
            lastHeartbeat: Date.now(),
          };

          localStorage.setItem("axolop_master_tab", JSON.stringify(masterInfo));
          this.broadcast("MASTER_ELECTION", {
            action: "become_master",
            masterInfo,
          });
          this.log(`Tab ${this.tabId} became master`);
        }

        async challengeMaster(currentMaster) {
          if (this.tabId < currentMaster.tabId) {
            this.setAsMaster();
          } else {
            this.isMaster = false;
            this.log(
              `Tab ${this.tabId} acknowledges master: ${currentMaster.tabId}`,
            );
          }
        }

        startHeartbeat() {
          this.heartbeatInterval = setInterval(() => {
            this.lastHeartbeat = Date.now();

            if (this.isMaster) {
              const masterInfo = this.getStoredMaster();
              if (masterInfo && masterInfo.tabId === this.tabId) {
                masterInfo.lastHeartbeat = Date.now();
                localStorage.setItem(
                  "axolop_master_tab",
                  JSON.stringify(masterInfo),
                );
              }
            }

            this.broadcast("HEARTBEAT", { isMaster: this.isMaster });
          }, 3000);
        }

        async acquireMutex(lockName, timeout = 5000) {
          if (this.mutexLocks.has(lockName)) {
            return false;
          }

          const lockKey = `axolop_mutex_${lockName}`;
          const lockData = {
            tabId: this.tabId,
            timestamp: Date.now(),
          };

          try {
            localStorage.setItem(lockKey, JSON.stringify(lockData));

            const stored = localStorage.getItem(lockKey);
            const parsed = JSON.parse(stored);

            if (parsed.tabId === this.tabId) {
              this.mutexLocks.set(lockName, Date.now() + timeout);
              this.broadcast("MUTEX_LOCK", { lockName, tabId: this.tabId });
              this.log(`Acquired mutex: ${lockName}`);
              return true;
            }
          } catch (error) {
            this.log("Failed to acquire mutex");
          }

          return false;
        }

        releaseMutex(lockName) {
          if (!this.mutexLocks.has(lockName)) {
            return false;
          }

          const lockKey = `axolop_mutex_${lockName}`;

          try {
            localStorage.removeItem(lockKey);
            this.mutexLocks.delete(lockName);
            this.broadcast("MUTEX_UNLOCK", { lockName, tabId: this.tabId });
            this.log(`Released mutex: ${lockName}`);
            return true;
          } catch (error) {
            this.log("Failed to release mutex");
            return false;
          }
        }

        canShowModal(modalType) {
          if (modalType === "mandatory") {
            return this.isMaster;
          }
          return true;
        }

        broadcastModalState(modalType, isOpen, data = {}) {
          this.broadcast("MODAL_STATE", { modalType, isOpen, data });
        }

        handleModalState(data, tabId) {
          this.log(
            `Modal state from ${tabId}: ${data.modalType} is ${data.isOpen ? "open" : "closed"}`,
          );
          updateModalResult(data, tabId);
        }

        handleTestMessage(data, tabId) {
          this.log(`Test message from ${tabId}: ${JSON.stringify(data)}`);
          updateCommResult(data, tabId);
        }

        log(message) {
          const timestamp = new Date().toLocaleTimeString();
          const logElement = document.getElementById("eventLog");
          logElement.innerHTML += `[${timestamp}] ${message}\n`;
          logElement.scrollTop = logElement.scrollHeight;
        }

        getStatus() {
          return {
            tabId: this.tabId,
            isMaster: this.isMaster,
            lastHeartbeat: this.lastHeartbeat,
            activeLocks: Array.from(this.mutexLocks.keys()),
            masterInfo: this.getStoredMaster(),
          };
        }

        cleanup() {
          if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
          }

          this.mutexLocks.forEach((_, lockName) => {
            this.releaseMutex(lockName);
          });

          if (this.isMaster) {
            localStorage.removeItem("axolop_master_tab");
          }

          if (this.broadcastChannel) {
            this.broadcastChannel.close();
          }
        }
      }

      // Initialize TabCoordinator
      const tabCoordinator = new TabCoordinatorTest();

      // UI Functions
      function updateTabStatus() {
        const status = tabCoordinator.getStatus();
        const statusElement = document.getElementById("tabStatus");

        statusElement.innerHTML = `
                <p><strong>Tab ID:</strong> ${status.tabId}</p>
                <p><strong>Master Status:</strong> <span class="status ${status.isMaster ? "master" : "slave"}">${status.isMaster ? "MASTER" : "SLAVE"}</span></p>
                <p><strong>Last Heartbeat:</strong> ${new Date(status.lastHeartbeat).toLocaleTimeString()}</p>
                <p><strong>Active Locks:</strong> ${status.activeLocks.length > 0 ? status.activeLocks.join(", ") : "None"}</p>
            `;
      }

      function updateMutexResult(result, type) {
        const resultElement = document.getElementById("mutexResult");
        resultElement.innerHTML = `
                <div class="result ${result.success ? "success" : "error"}">
                    <strong>${type}:</strong> ${result.message}
                    ${result.details ? `<br><small>Details: ${JSON.stringify(result.details)}</small>` : ""}
                </div>
            `;
      }

      function updateModalResult(data, sourceTab) {
        const resultElement = document.getElementById("modalResult");
        resultElement.innerHTML += `
                <div class="result info">
                    <strong>Modal Update from ${sourceTab}:</strong> ${data.modalType} is ${data.isOpen ? "open" : "closed"}
                </div>
            `;
      }

      function updateCommResult(data, sourceTab) {
        const resultElement = document.getElementById("commResult");
        resultElement.innerHTML = `
                <div class="result success">
                    <strong>Message from ${sourceTab}:</strong> ${JSON.stringify(data)}
                </div>
            `;
      }

      function updateTestResults(results) {
        const resultsElement = document.getElementById("testResults");
        const passedCount = results.filter((r) => r.passed).length;
        const totalCount = results.length;
        const successRate =
          totalCount > 0 ? ((passedCount / totalCount) * 100).toFixed(1) : 0;

        resultsElement.innerHTML = `
                <p><strong>Tests Run:</strong> ${totalCount}</p>
                <p><strong>Passed:</strong> ${passedCount}</p>
                <p><strong>Success Rate:</strong> ${successRate}%</p>
                ${results
                  .map(
                    (r) => `
                    <div class="result ${r.passed ? "success" : "error"}">
                        <strong>${r.testName}:</strong> ${r.message}
                    </div>
                `,
                  )
                  .join("")}
            `;
      }

      // Test Functions
      window.checkTabStatus = function () {
        updateTabStatus();
      };

      window.testMutex = async function () {
        const lockAcquired = await tabCoordinator.acquireMutex(
          "test-lock",
          5000,
        );
        updateMutexResult(
          {
            success: lockAcquired,
            message: lockAcquired
              ? "Mutex acquired successfully"
              : "Failed to acquire mutex",
            details: { lockAcquired },
          },
          "Acquire Lock",
        );
      };

      window.testMutexConflict = async function () {
        const lock1 = await tabCoordinator.acquireMutex("conflict-test", 5000);
        const lock2 = await tabCoordinator.acquireMutex("conflict-test", 1000);

        updateMutexResult(
          {
            success: lock1 && !lock2,
            message:
              lock1 && !lock2
                ? "Conflict prevention working"
                : "Conflict prevention failed",
            details: { firstLock: lock1, secondLock: lock2 },
          },
          "Conflict Test",
        );
      };

      window.testModalPermission = function () {
        const canShowMandatory = tabCoordinator.canShowModal("mandatory");
        const canShowOptional = tabCoordinator.canShowModal("optional");

        const resultElement = document.getElementById("modalResult");
        resultElement.innerHTML = `
                <div class="result ${canShowMandatory ? "success" : "error"}">
                    <strong>Can Show Mandatory Modal:</strong> ${canShowMandatory ? "Yes (Master Tab)" : "No (Slave Tab)"}
                </div>
                <div class="result ${canShowOptional ? "success" : "error"}">
                    <strong>Can Show Optional Modal:</strong> ${canShowOptional ? "Yes" : "No"}
                </div>
            `;
      };

      window.simulateModalOpen = function () {
        tabCoordinator.broadcastModalState("mandatory", true, {
          source: "test",
        });
      };

      window.testCommunication = function () {
        const testData = { timestamp: Date.now(), message: "Hello from tab!" };
        tabCoordinator.broadcast("TEST_MESSAGE", testData);
      };

      window.runAllTests = async function () {
        const tests = [];

        // Test 1: Tab Status
        const status = tabCoordinator.getStatus();
        tests.push({
          testName: "Tab Status",
          passed: !!status.tabId && !!status.lastHeartbeat,
          message: !!status.tabId
            ? "Tab initialized properly"
            : "Tab initialization failed",
        });

        // Test 2: Mutex
        const lockAcquired = await tabCoordinator.acquireMutex(
          "test-all",
          2000,
        );
        const lockReleased = tabCoordinator.releaseMutex("test-all");
        tests.push({
          testName: "Mutex Mechanism",
          passed: lockAcquired && lockReleased,
          message:
            lockAcquired && lockReleased
              ? "Mutex working correctly"
              : "Mutex has issues",
        });

        // Test 3: Modal Permission
        const canShowMandatory = tabCoordinator.canShowModal("mandatory");
        const expectedMandatory = status.isMaster;
        tests.push({
          testName: "Modal Permission",
          passed: canShowMandatory === expectedMandatory,
          message:
            canShowMandatory === expectedMandatory
              ? "Modal permissions correct"
              : "Modal permissions incorrect",
        });

        updateTestResults(tests);
      };

      window.clearResults = function () {
        document.getElementById("testResults").innerHTML =
          "<p>No tests run yet</p>";
      };

      window.exportResults = function () {
        const results = {
          timestamp: Date.now(),
          status: tabCoordinator.getStatus(),
          userAgent: navigator.userAgent,
        };

        const blob = new Blob([JSON.stringify(results, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `multisession-test-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      };

      window.clearLog = function () {
        document.getElementById("eventLog").innerHTML = "";
      };

      // Auto-update status
      setInterval(updateTabStatus, 2000);

      // Initial status update
      setTimeout(updateTabStatus, 1000);
    </script>
  </body>
</html>
